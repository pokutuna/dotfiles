import
class
case class
object
case object
trait
type
extends
with
this
new
def
if
else
case
for
while
synchronized
override
abstract
abstract override
private
protected
final
sealed
implicit
-
::
=>
<-
-
var
val
lazy val
-
Seq
List
Array
Map
String
Boolean
Any
AnyRef
AnyVal
Unit
-
try
catch
finally
throw
Exception
-
apply
update
yield
match
println
.equals
-
.toInt
.toString
.toDouble
-
Iterable
hasDefiniteSize
isEmpty
toList
toSeq
toStream
elements
projection
mkString
addString
copyToArray
copyToBuffer
takeWhile
dropWhile
indexOf
findIndexOf
sameElements
filter
foreach
map
flatMap
exsit
find
forall
partition
foldLeft
foldRight
/:
:\
reduceLeft
reduceRight
-
Collection
size
toArray
stringPrefix
-
Seq
length
lengthCompare
reverse
take
drop
first
firstOption
last
lastOption
lastIndexOf
slice
contains
containsSlice
startsWith
endsWith
equalsWith
-
List
apply
::
:::
head
tail
init
dropRight
takeRigth
flatten
+
-
--
remove
removeDuplicates
indices
count
span
break
splitAt
intersect
union
sort
reverseMap
reverse_:::
zip
zipAll
zipWithIndex
unapplySeq
concat
make
tabulate
range
fromArray
fromIterator
fromString
toString
exists2
forall2
map2
map3
mapConserve
transpose
unzip
lefts
rights
separate
-
Option
Some
None
orElse
isDefined
elements
filter
flatMap
foreach
map
isEmpty
toList
get
getOrElse
toLeft
toRight
-
Either
isLeft
isRight
left
right
swap
fold
cond
joinLeft
joinRight
merge